## 对象的属性类型 

### 数据属性

> 数据属性有4个描述其行为的特性 

1. [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。

2. [[Enumerable]]: 表示能否通过for-in循环返回属性。早期和对象字面量那样直接在对象上定义的属性，它们的这个特性默认值为true 。

3. [[Writable]]: 表示能否修改属性的值。早期和对象字面量那样直接在对象上定义的属性，它们的这个特性默认值为true。

4. [[value]]: 包含这个属性的数据值。读取属性时，从这个位置读; 写入属性值时, 将新值保存在这个位置。这个值的默认值是undefined。

**像最简单的创建对象的 方法(var p = new Object();person.name = 'yzf';)和对象字面量那样直接在对象上定义的属性，它们的[   [Cnofigurable]]、[[Enumerable]]、[[Writable]]特性都被默认为true**

如果想要修改默认的特性，必需使用ECMAScript5的Object.defineProperty()方法。

``` javascript
// 它包含三个参数：属性所在对象、属性的名字和一个描述符对象和一个描述符对象
// 描述符对象的属性必须是：configurable、enumerable、writable和value。设置一个或多个值，可以修改对应的特性值。

var person = {};
Object.defineProperty(person, 'name', {
	writable: false,
	value: 'yzf'
});
alert(person.name); // 'yzf'
person.name = 'hwy';
alert(person.name); // 'yzf'

// 或者这样
var person = {};
Object.defineProperty(person, 'name', {
	configurable: false,
	value: 'yzf'
});
alert(person.name); // 'yzf'
delete person.name; // 删除不了
alert(person.name); // 'yzf'
person.name = 'hwy'; 
alert(person.name); // 'yzf' 
// 因为调用defineProperty()方法时，不指定的话，configurable、enumerable、writable的默认值是false。
```


注意： 
``` javascript
var person = {};
Object.definePropery(person, 'name', {
	configurable: false,
	value: 'yzf'
});
alert(person.name); // 'yzf'
Object.defineProperty(person, 'name', {
	configurable: true,
	value: 'hwy'
});
alert(person.name); // error, Cannot redefine property: name
// 因为一旦将属性定义为不可配置的，就不可以将它变回可配置的。
```

注意:
**在调用Object.defineProperty()方法时,如果不指定，configurable 、enumerable、writable特性的默认值都是false**

### 访问器属性

> 访问器属性不包含数据值; 它包含一对getter和setter函数(不过，这两个函数都不是必须的)。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值; 在写入访问器属性时，会调用setter函数并传入新值，这个函数决定如何处理数据。访问器属性有下面四个特性。

1. [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值是true。

2. [[Enumerable]]: 示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值是true。

3. [[Get]]: 在读取属性时调用的函数，默认值是undefined

4. [[Set]]: 在写入属性时调用的函数，默认值是undefined

访问器属性不能直接定义，必须使用Object.defineProperty()来定义，如：

``` javascript
// _year前面加上的下划线表示只能通过对象方法访问的属性。

var book = {
	_year: 2004,
	edition: 1
}

Object.defineProperty(book, 'year', {
	get: function() {
		return this._year;
	},
	set: function(newValue) {
		if(newValue > 2004) {
			this._year = newValue;
			this.edition += newValue - 2004;
		}
	}
});

book.year = 2005;
console.log(book.edition); // 2
```

### 定义多个属性

由于为对象定义多个属性的可能性比较大，ECMA5又制订了一个<code>Object.defineProperties()</code>方法。 

```
var book = {};

Object.defineProperties(book, {
	_year: {
		value: 2004
	},
	edition: {
		value: 1
	}, 
	year: {
		get: function() {
			return this._year;
		},
		set: function(newValue) {
			if(newValue > 2004) {
				this._year = newValue;
				this.edition += newValue - 2004;
			}
		}
	}
});
```

### 读取属性的特性

使用ECMA5的<code>Object.getOwnPropertyDescriptor()</code>方法，可以取得给定属性的描述符。

```
var book = {};

Object.defineProperties(book, {
	_year: {
		value: 2004
	},
	edition: {
		value: 1
	}, 
	year: {
		get: function() {
			return this._year;
		},
		set: function(newValue) {
			if(newValue > 2004) {
				this._year = newValue;
				this.edition += newValue - 2004;
			}
		}
	}
});

var des = Object.getOwnPropertyDescriptor(book, "_year");
console.log(des.value); // 2004
console.log(des.configurable); // false
```	


## 创建对象的方法

### 最早期

> 最早期是使用这样的模式创建对象的

``` javascript
var person = new Object();
person.name = 'yzf';
person.age = 18;
person.job = 'stu';
person.sayName = function() {
	alert(this.name);	
};
```

### 对象字面量

``` javascript
var person = {
	name: 'yzf',
	age: 18,
	job: 'stu',
	sayName: function() {
		alert(this.name);
	}
};
```

### 工厂模式

> 这个模式有一个缺点，无法解决对象识别的问题，于是有了构造函数 

``` javascript
function person(name, age, job) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = obj;
	o.sayName = function() {
		alert(this.name);
	};
	return o;
}
var person1 = person('yzf', 18, 'stu');
```

### 构造函数

``` javascript
function Person(name, age, job) {
	this.name = name;	
	this.age = age;
	this.job = job;
	this.sayName = function() {
		alert(this.name);
	};
}
var person1 = new Person('yzf', 18, 'stu');
// 过程:
// 1. 创建一个新对象 
// 2. Person的this指向新对象
// 3. 执行代码
// 4. 返回这个新对象


// 理解
// 1. 对象拥有constructor属性，该属性是一个指针，指向构造函数
// 2. 检测对象类型: person1.constructor == Person, 或者person1 instanceof Person(推荐)
// 3. 构造函数的使用

		a. var person1 = new Person('yzf', 18, 'stu'); 
		b. Person('yzf', 18, 'stu');window.sayName(); // 普通函数调用，'yzf' 
		c. 在另一个对象的作用域中调用
			var o = new Object();
			Person.call(o, 'yzf', 18, 'stu');
			o.sayName(); // 'yzf'

// 问题
// 每个方法在每个实例上重新创建一遍
// 相当于每定义一个函数，就实例化了一个对象，
// 同一个功能居然要创建那么多函数
// 所以就有了原型模式
```

### 原型模式

#### 理解原型对象 

**基本理解：**

1. 每个函数都有一个prototype(原型)属性, 这个属性是一个指针
2. 这个指针指向一个对象
3. 这个对象的用途是包含可以 有特定类型的  所有实例  共享的属性和方法
4. 这样理解，如图：

![](images/01.jpg)

``` javascript
function Person() {
	
}
Person.prototype.name = 'yzf';
Person.prototype.age = 18;
Person.prototype.job = 'stu';
Person.prototype.sayName = function() {
	alert(this.name);
};
var person1 = new Perosn(); 
person1.sayName(); // 'yzf'
var person2 = new Person();
person2.sayName(); // 'yzf'
```

**深入理解**

1. 所有原型对象自动获得一个constructor(构造函数)属性，该属性包含一个指针。

2. 该指针指向prototype属性所在的函数。这个constructor也是共享的。

3. 原型对象的其他方法从Object继承过来。

4. 当调用构造函数创建一个新的实例后，该实例的内部包含一个指针([[prototype]]), 它指向原型对象，它与构造函数没有任何关系。

5. 仅仅通过空构造函数+原型对象创建的实例，不包含属性和方法, 但是可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。

6. [[prototype]]无法被访问，但是有方法可以确定对象之间是否存在这种关系。

``` javascrpit

// 1. 
alert(Person.prototype.isPrototypeOf(person1)); // true

// 2.
alert(Object.getPrototypeOf(person1) == Person.prototype); // true
alert(Object.getPrototypeOf(person1).name); // 'yzf'

// 3.
alert(person1.hasOwnProperty("name")); // 如果实例有则返回true
```

7. 每当代码读取某个对象的属性时，搜索首先在对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值;如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有刚给定名字的属性，如果找到了，则返回该属性的值。

8. 虽然可以通过实例访问保存在原型对象中的值，但是不能通过对象实例重写原型中的值。

9. 如果实例中的属性和原型对象的属性同名，则实例中的属性会屏蔽掉原型对象的属性。

10. 可以通过delete完全删除实例属性，从而可以访问原型中的属性。


#### in操作符

```
// 因为in操作符的特性 所以可以利用函数hasOwnProperty来实现一个判断原型中属性的函数
function hasPrototypeProperty(object, name) {
	return !object.hasOwnPropery(name) && (name in object);
} 
```

1. <code>"name" in person1</code>, 无论是实例还是原型中有name的话，都返回true

2. 使用for-in操作符

	1. 能够通过对象访问的，可以枚举的属性，不管原型中还是实例中，都可以返回

	2. (屏蔽了原型中不可枚举属性的)  实例属性也可以在for-in中返回

	3. 因为规定，所有开发人员定义的属性是可枚举的(在IE8及以前版本存在bug)

	4. 这个bug导致，(屏蔽了原型中不可枚举属性的)  实例属性不可以在for-in中返回

	5. 所以要取得对象上所有可枚举的实例属性, 可以用方法<code>Object.keys(参数是对象)</code>

	6. 要取得对象上所有实例属性，不管是否可以枚举，可以用方法<code>Object.getOwnPropertyNames(参数是对象)</code>


```
// 代码测试

function Person() {

}
Person.prototype.name = "yzf";
Person.prototype.age = 18;
Person.prototype.job = "stu";
Person.prototype.sayName = function() {
	console.log(this.name);
};
var keys = Object.keys(Person.prototype); 
console.log(keys); // "name, age, job, sayName"

var p1 = new Person();
p1.name = "hwy";
p1.age = "17";
var p1keys = Object.keys(p1);
console.log(p1keys); // "name, age"

var keys2 = Object.getOwnPropertyNames(Person.prototype);
console.log(keys2); // "constructor, name, age, job, sayName"

var p2 = new Person();
p2.name = "hwy";
p2.age = "17";
var p2keys = Object.getOwnPropertyNames(p2);
console.log(p2keys); // "name, age"
```

#### 更简单的原型语法

> 也就是重写原型对象 

1. 将原型对象写成对象字面量的形式

2. 其他的都和Person.prototype.name这样的写法一样，唯一的不同就是constructor不再指向Person了

3. 之前，每创建一个函数, 就同时会创建它的prototype对象, 该对象也会自动获得constructor属性。

4. 现在，本质上重写了prototype对象，因此constructor也就成了新的constructor, 它不再指向Person函数了，而是指向Object的构造函数。

5. 尽管通过instanceof操作符可以得到true，但是如果用constructor属性，得到的是false。

6. 那么如果constructor很重要，需要它指向Person函数，可以写<code>constructor: Person</code>, 但是此时它是枚举的，而默认的constructor是不可枚举的。

7. 那么我们可以使用<code>Object.defineProperty()</code>来设置constructor不可枚举。


```
function Person() {
	
}
Person.prototype = {
	name: 'yzf',
	age: '18',
	job: 'stu'
}
var friend = new Person();
console.log(friend instanceof Person); // true
console.log(friend instanceof Object); // true
console.log(friend.constructor ==  Object); // true
console.log(friend.constructor ==  Person); // false 
```

#### 原型的动态性

1. 由于在原型中查找值的过程是一次搜索，因此我对原型对象所做的任何修改都能立即从实例上反映出来---即使是先创建了实例后修改原型也照样如此。 

2. 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。

3. 我们知道，调用构造函数时会为实例添加一个指向最初原型的[[prototype]]指针, 而把原型修改为另一个对象就等于切断了构造函数与最初原型直接的联系。

4. 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系;它们引用的是最初的原型。

```
// 代码测试
function Person() {
	
}
var friend = new Person();
Person.prototype.sayHi = function() {
	alert("hi");
};
friend.sayHi(); // "hi", 没有问题


// 如果这样，会报错
function Person() {
	
}
var friend = new Person();

Person.prototype = {
	constructor: Person,
	name: "yzf",
	age: 18,
	job: "stu",
	sayName: function() {
		console.log(this.name);
	}
};

friend.sayName(); // error

```

#### 原生对象的原型

> 所有原生的引用类型都是用原型模式创建的，所以可以为引用类型对象添加方法，但是并不建议这么做。。

#### 原型对象的问题

1. 原型模式最大的问题是由共享造成的。

2. 如果原型对象有属性是引用类型的，那么它将是共享的，所有实例共享它，所以就出现了问题。

3. 因为属性一般是不要求共享的，这是要方法共享就可以了。

4. 所以就有了组合使用构造函数模式和原型模式，可以说，**这是用来定义引用类型的一种默认模式**。


### 组合使用构造函数模式和原型模式

1. 构造函数模式用于定义实例属性, 而原型属性用于定义方法和共享的属性。	

2. 结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。

```
function Person(name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
	this.friends = ['yzfff', 'hwyyy'];
}

Person.prototype = {
	constructor: Person,
	sayName: function() {
		console.log(this.name);	
	}
}

var p1 = new Person('yzf', 18, 'stu');
var p2 = new Person('hwy', 17, 'stu');
p1.friends.push('memeda');
console.log(p1.friends); // 'yzfff, hwyyy, memeda'
console.log(p2.friends); // 'yzfff, hwyyy'
console.log(p1.friends == p2.friends); // false
console.log(p1.sayName == p1.sayName); // true
```


### 动态原型模式

1. 有其他OO语言的开发人员看到独立的构造函数和原型时，会疑惑，而动态原型模式正是解决这样的问题的。

2. 动态原型模式将所有信息都封装在构造函数中。通过构造函数来初始化原型(仅在必要的情况下)。

```
function Person(name, age, job) {
	// 属性
	this.name = name;	
	this.age = age;
	this.job = job;

	// 方法
	// 只会执行一次，执行完后，原型初始化结束。
	if(typeof this.sayName != 'function') {
		Person.prototype.sayName = function() {
			console.log(this.name);
		};
	}
}

var p1 = new Person('yzf', 18, 'stu');  
p1.sayName(); // 'yzf'
```

3. 只需要写一个if就可以了，不需要写多个。 

4.  使用动态原型模式时，不能使用对象字面量重写原型。

```
// 看这里的例子
function Person(name, age, job) {
	//  属性
	this.name = name;
	this.age = age;
	this.job = job;

	// 方法
	if(typeof this.sayName != 'function') {
		Person.prototype = {
			constructor: Person,
			sayName: function() {
				console.log(this.name);	
			}
		};	
	}
}
var p1 = new Person('yzf', 18, 'stu');
var p2 = new Person('hwy', 17, 'stu');
console.log(typeof p1.sayName); // undefined
console.log(typeof p2.sayName); // function
console.log(typeof p1.sayHi); // undefined

// 原因
// 调用构造函数时会为实例添加一个指向最初原型的[[prototyep]]指针
// 然后再运行构造函数的代码, 在代码里重写原型对象, 这个时候有另一个原型对象了。
// 也就是说p1的原型对象和p2的原型对象不是同一个。
// p1的原型对象是调用构造函数时，默认的原型对象。
// p2的原型对象是重写后的那一个。
// 我们需要做的就是要搞清对象实例的原型对象是哪一个原型对象即可。

```

5. 如果非要使用字面量的话，可以这样。

```
[来自于知乎](https://www.zhihu.com/question/41441895)
function Person(name, age, job) {
	if(typeof this.sayName != 'function') {
		Person.prototype = {
			constructor: Person,
			sayName: function() {
				console.log(this.name);
			}
		}
		// 初次运行时, 重新调用构造函数返回
		return new Person(name, age, job);
	}

	// 属性
	this.name = name;
	this.age = age;
	this.job = job;
}
var p1 = new Person('yzf', 18, 'stu');
var p2 = new Person('hwy', 17, 'stu');
console.log(typeof p1.sayName); // function
console.log(typeof p2.sayName); // function
```


### 寄生构造函数模式

> 可以用于为原生构造函数添加特殊的属性 

1. 这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码, 然后再返回新创建的对象。

2. 除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式和工厂模式是一模一样的。

3. 构造函数在不返回值的情况下，默认返回新对象实例。而通过在构造函数末尾添加一个return语句，可以重写调用构造函数时返回的值。

```
// 代码测试
function Person(name, age, job) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function() {
		console.log(this.name);
	};
	return o;
}

var p1 = new Person('yzf', 18, 'stu');
p1.sayName(); //'yzf'
```

4. 这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想要创建一个具有额外方法的特殊数组。

```
// 因为不能直接修改Array构造函数, 因此可以使用这个模式

// 假如直接为Array添加这样的一个方法，那么会污染其他数组变量。它们并不需要这个方法。
function SpecialArray() {
	// 创建数组
	var values = new Array();
	
	// 添加值
	values.push.apply(values, arguments);

	// 添加方法
	values.toPipedString = function() {
		return this.join("|");
	};

	// 返回数组
	return values;
}

var colors = new SpecialArray('red', 'blue', 'green');
console.log(colors.toPipedString()); // 'red|blue|green'

```

5. 构造函数返回的对象 和 在构造函数外部创建的对象没有什么不同。


### 稳妥构造函数

1. 所谓稳妥对象, 指的是没有公共属性, 而且其方法也不引用this的对象。

2. 它适合在一些安全的环境中(这些环境禁止使用this和new), 或者防止数据被其他程序改动时使用。

3. 稳妥构造函数遵循与寄生构造函数类似的模式。

4. 但是有两点不同，一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数。

```
function Person(name, age, job) {

	// 创建要返回的对象
	var o = new Object();

	// 可以在这里定义私有变量和函数 

	// 添加方法
	o.sayName = function() {
		console.log(name);
	}

	// 返回对象
	return o;
}

var p1 = Person('yzf', 18, 'stu');
p1.sayName(); // 'yzf'
p1.name = 'hwy';
p1.sayName(); // 'yzf' // 不能修改，因为非this
```


## 继承