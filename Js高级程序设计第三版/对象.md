## 对象的属性类型 

### 数据属性

> 数据属性有4个描述其行为的特性 

1. [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。

2. [[Enumerable]]: 表示能否通过for-in循环返回属性。早期和对象字面量那样直接在对象上定义的属性，它们的这个特性默认值为true。

3. [[Writable]]: 表示能否修改属性的值。早期和对象字面量那样直接在对象上定义的属性，它们的这个特性默认值为true。

4. [[value]]: 包含这个属性的数据值。读取属性时，从这个位置读; 写入属性值时, 将新值保存在这个位置。这个值的默认值是undefined。

**像最简单的创建对象的 方法(var p = new Object();person.name = 'yzf';)和对象字面量那样直接在对象上定义的属性，它们的[   [Cnofigurable]]、[[Enumerable]]、[[Writable]]特性都被默认为true**

如果想要修改默认的特性，必需使用ECMAScript5的Object.defineProperty()方法。

``` javascript
// 它包含三个参数：属性所在对象、属性的名字和一个描述符对象和一个描述符对象
// 描述符对象的属性必须是：configurable、enumerable、writable和value。设置一个或多个值，可以修改对应的特性值。

var person = {};
Object.defineProperty(person, 'name', {
	writable: false,
	value: 'yzf'
});
alert(person.name); // 'yzf'
person.name = 'hwy';
alert(person.name); // 'yzf'

// 或者这样
var person = {};
Object.defineProperty(person, 'name', {
	configurable: false,
	value: 'yzf'
});
alert(person.name); // 'yzf'
delete person.name; // 删除不了
alert(person.name); // 'yzf'
person.name = 'hwy'; 
alert(person.name); // 'yzf' 
// 因为调用defineProperty()方法时，不指定的话，configurable、enumerable、writable的默认值是false。
```


注意： 
``` javascript
var person = {};
Object.definePropery(person, 'name', {
	configurable: false,
	value: 'yzf'
});
alert(person.name); // 'yzf'
Object.defineProperty(person, 'name', {
	configurable: true,
	value: 'hwy'
});
alert(person.name); // error, Cannot redefine property: name
// 因为一旦将属性定义为不可配置的，就不可以将它变回可配置的。
```

注意:
*** 在调用Object.defineProperty()方法时，如果不指定，configurable 、enumerable、writable特性的默认值都是false  ***

### 访问器属性

> 访问器属性不包含数据值; 它包含一对getter和setter函数(不过，这两个函数都不是必须的)。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值; 在写入访问器属性时，会调用setter函数并传入新值，这个函数决定如何处理数据。访问器属性有下面四个特性。

1. [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值是true。

2. [[Enumetable]]: 示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值是true。

3. [[Get]]: 在读取属性时调用的函数，默认值是undefined

4. [[Set]]: 在写入属性时调用的函数，默认值是undefined

访问器属性不能直接定义，必须使用Object.defineProperty()来定义，如：

``` javascript
```




## 创建对象的方法

### 最早期

> 最早期是使用这样的模式创建对象的

``` javascript
var person = new Object();
person.name = 'yzf';
person.age = 18;
person.job = 'stu';
person.sayName = function() {
	alert(this.name);	
};
```

### 对象字面量

``` javascript
var person = {
	name: 'yzf',
	age: 18,
	job: 'stu',
	sayName: function() {
		alert(this.name);
	}
};
```

### 工厂模式

> 这个模式有一个缺点，无法解决对象识别的问题，于是有了构造函数 

``` javascript
function person(name, age, job) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = obj;
	o.sayName = function() {
		alert(this.name);
	};
	return o;
}
var person1 = person('yzf', 18, 'stu');
```

### 构造函数

``` javascript
function Person(name, age, job) {
	this.name = name;	
	this.age = age;
	this.job = job;
	this.sayName = function() {
		alert(this.name);
	};
}
var person1 = new Person('yzf', 18, 'stu');
// 过程:
// 1. 创建一个新对象 
// 2. Person的this指向新对象
// 3. 执行代码
// 4. 返回这个新对象


// 理解
// 1. 对象拥有constructor属性，该属性是一个指针，指向构造函数
// 2. 检测对象类型: person1.constructor == Person, 或者person1 instanceof Person(推荐)
// 3. 构造函数的使用

		a. var person1 = new Person('yzf', 18, 'stu'); 
		b. Person('yzf', 18, 'stu');window.sayName(); // 普通函数调用，'yzf' 
		c. 在另一个对象的作用域中调用
			var o = new Object();
			Person.call(o, 'yzf', 18, 'stu');
			o.sayName(); // 'yzf'

// 问题
// 每个方法在每个实例上重新创建一遍
// 相当于每定义一个函数，就实例化了一个对象，
// 同一个功能居然要创建那么多函数
// 所以就有了原型模式
```

### 原型模式

**理解：**




## other

### new关键字 

``` javascript
function Hero(a) {
	this.a = a;	
}
var h = Hero("mm");
typeof h;// its 'undefined', because no 'new', so its a simple function(has a returnvalue 'undefined')
```

### 构造器属性

> 当我们创建对象时，实际上同时也赋予了该对象一种特殊的属性---即构造器属性。该属性实际上就是一个指向用于创建该对象的构造器函数的引用。

``` javascript
function Hero(a) {
	this.a = a;	
}
var h = new Hero("mm");
alert(h.constructor); // function Hero(a) {this.a = a}
```